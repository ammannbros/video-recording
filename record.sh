#!/usr/bin/env bash
# shellcheck disable=SC2154

#
# ARG_OPTIONAL_SINGLE([duration],[d],[Duration of recording],[02:00:00])
# ARG_OPTIONAL_SINGLE([output-directory],[o],[Specify output directory],[.])
# ARG_OPTIONAL_SINGLE([crf],[],[crf to use for encoding],[23])
# ARG_OPTIONAL_BOOLEAN([preview],[],[do not show a live preview],[off])
# ARG_POSITIONAL_SINGLE([id],[the id of the video recording],[])
# ARG_HELP([Script to record from a video card])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.10.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info


die()
{
	local _ret="${2:-1}"
	test "${_PRINT_HELP:-no}" = yes && print_help >&2
	echo "$1" >&2
	exit "${_ret}"
}


begins_with_short_option()
{
	local first_option all_short_options='doh'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_duration="02:00:00"
_arg_output_directory="."
_arg_crf="23"
_arg_preview="off"


print_help()
{
	printf '%s\n' "Script to record from a video card"
	printf 'Usage: %s [-d|--duration <arg>] [-o|--output-directory <arg>] [--crf <arg>] [--(no-)preview] [-h|--help] <id>\n' "$0"
	printf '\t%s\n' "<id>: the id of the video recording"
	printf '\t%s\n' "-d, --duration: Duration of recording (default: '02:00:00')"
	printf '\t%s\n' "-o, --output-directory: Specify output directory (default: '.')"
	printf '\t%s\n' "--crf: crf to use for encoding (default: '23')"
	printf '\t%s\n' "--preview, --no-preview: do not show a live preview (off by default)"
	printf '\t%s\n' "-h, --help: Prints help"
}


parse_commandline()
{
	_positionals_count=0
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			-d|--duration)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_duration="$2"
				shift
				;;
			--duration=*)
				_arg_duration="${_key##--duration=}"
				;;
			-d*)
				_arg_duration="${_key##-d}"
				;;
			-o|--output-directory)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_output_directory="$2"
				shift
				;;
			--output-directory=*)
				_arg_output_directory="${_key##--output-directory=}"
				;;
			-o*)
				_arg_output_directory="${_key##-o}"
				;;
			--crf)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_crf="$2"
				shift
				;;
			--crf=*)
				_arg_crf="${_key##--crf=}"
				;;
			--no-preview|--preview)
				_arg_preview="on"
				test "${1:0:5}" = "--no-" && _arg_preview="off"
				;;
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			*)
				_last_positional="$1"
				_positionals+=("$_last_positional")
				_positionals_count=$((_positionals_count + 1))
				;;
		esac
		shift
	done
}


handle_passed_args_count()
{
	local _required_args_string="'id'"
	test "${_positionals_count}" -ge 1 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require exactly 1 (namely: $_required_args_string), but got only ${_positionals_count}." 1
	test "${_positionals_count}" -le 1 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect exactly 1 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}')." 1
}


assign_positional_args()
{
	local _positional_name _shift_for=$1
	_positional_names="_arg_id "

	shift "$_shift_for"
	for _positional_name in ${_positional_names}
	do
		test $# -gt 0 || break
		eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
		shift
	done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args 1 "${_positionals[@]}"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash


id=$_arg_id

if [ -z "$id" ]
then
  echo "id can not be empty"
  exit 1
fi

crf=$_arg_crf

today=$(date '+%Y-%-m-%d_%H-%M-%S');
title="${id}_${today}_crf-${crf}"
input=$_arg_input
output_directory=$_arg_output_directory

if [ ! -d "$output_directory" ]
then
  echo "output directory must exist"
  exit 1
fi

output="$output_directory/$title.mp4"
log_file="$output_directory/$title.log"

ffmpeg_program=$(cat <<ENDFFMPEG
  ffmpeg -f v4l2 -standard PAL -thread_queue_size 1024 -i /dev/video0 \
    -f alsa -thread_queue_size 1024 -i hw:2,0 \
    -vf "yadif=1" \
    -c:v libx264 -crf:v "$crf" -preset:v slow \
    -c:a aac -b:a 160k \
    -movflags +faststart -r 25 \
    -t $_arg_duration \
    -metadata author="Familie Ammann" \
    -metadata title="$title" \

ENDFFMPEG
)

echo "$_arg_preview"

if [ "$_arg_preview" = on ]
then
  ffmpeg_program="$ffmpeg_program $output -vf format=yuv420p -f sdl Preview |& tee $log_file"
else
  ffmpeg_program="$ffmpeg_program $output |& tee $log_file"
fi

echo "$ffmpeg_program"
eval "$ffmpeg_program |& tee $log_file"

echo "Video written to $output"

# ] <-- needed because of Argbash
